

### 2.smali及其语法

smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。

关键字

| 名称        | 注释                       |
| :---------- | :------------------------- |
| .class      | 类名                       |
| .super      | 父类名，继承的上级类名名称 |
| .source     | 源名                       |
| .field      | 变量                       |
| .method     | 方法名                     |
| .register   | 寄存器                     |
| .end method | 方法名的结束               |
| public      | 公有                       |
| protected   | 半公开，只有同一家人才能用 |
| private     | 私有，只能自己使用         |
| .parameter  | 方法参数                   |
| .prologue   | 方法开始                   |
| .line xxx   | 位于第xxx行                |

数据类型对应

| smali类型    | java类型                          | 注释                 |
| :----------- | :-------------------------------- | :------------------- |
| V            | void                              | 无返回值             |
| Z            | boolean                           | 布尔值类型，返回0或1 |
| B            | byte                              | 字节类型，返回字节   |
| S            | short                             | 短整数类型，返回数字 |
| C            | char                              | 字符类型，返回字符   |
| I            | int                               | 整数类型，返回数字   |
| J            | long （64位 需要2个寄存器存储）   | 长整数类型，返回数字 |
| F            | float                             | 单浮点类型，返回数字 |
| D            | double （64位 需要2个寄存器存储） | 双浮点类型，返回数字 |
| string       | String                            | 文本类型，返回字符串 |
| Lxxx/xxx/xxx | object                            | 对象类型，返回对象   |

常用指令

| 关键字       | 注释                                                   |
| :----------- | :----------------------------------------------------- |
| const        | 重写整数属性，真假属性内容，只能是数字类型             |
| const-string | 重写字符串内容                                         |
| const-wide   | 重写长整数类型，多用于修改到期时间。                   |
| return       | 返回指令                                               |
| if-eq        | 全称equal(a=b)，比较寄存器ab内容，相同则跳             |
| if-ne        | 全称not equal(a!=b)，ab内容不相同则跳                  |
| if-eqz       | 全称equal zero(a=0)，z即是0的标记，a等于0则跳          |
| if-nez       | 全称not equal zero(a!=0)，a不等于0则跳                 |
| if-ge        | 全称greater equal(a>=b)，a大于或等于则跳               |
| if-le        | 全称little equal(a<=b)，a小于或等于则跳                |
| goto         | 强制跳到指定位置                                       |
| switch       | 分支跳转，一般会有多个分支线，并根据指令跳转到适当位置 |
| iget         | 获取寄存器数据                                         |

### .安卓四大组件

| 组件                           | 描述                                                         |
| :----------------------------- | :----------------------------------------------------------- |
| Activity(活动)                 | 在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。 |
| Service(服务)                  | Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。 |
| Broadcast Receiver(广播接收器) | 一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。 |
| Content Provider(内容提供者)   | 作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等） |

#### activity的切换

```java
 <!---声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的 <activity> 元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。----->
        <activity  
            android:label="@string/app_name"  
            android:name="com.zj.wuaipojie.ui.MainActivity"  
            android:exported="true">  <!--当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动-->
            <!---指明这个activity可以以什么样的意图(intent)启动--->
            <intent-filter>  
                <!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动--->
                <action  
                    android:name="android.intent.action.MAIN" />  
                <!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity-->
                <category  
                    android:name="android.intent.category.LAUNCHER" />  
            </intent-filter>  
        </activity>  
        <activity  
            android:name="com.zj.wuaipojie.ui.ChallengeFirst" />
        <activity  
            android:name="com.zj.wuaipojie.ui.ChallengeFifth"  
            android:exported="true" />  
        <activity  
            android:name="com.zj.wuaipojie.ui.ChallengeFourth"  
            android:exported="true" />  
        <activity  
            android:name="com.zj.wuaipojie.ui.ChallengeThird"  
            android:exported="false" />  
        <activity  
            android:name="com.zj.wuaipojie.ui.ChallengeSecond"  
            android:exported="false" />  
        <activity  
            android:name="com.zj.wuaipojie.ui.AdActivity" />  
```

启动广告流程：
启动Activity->广告Activity->主页Activity

修改方法：
1.修改加载时间
2.Acitivity切换定位，修改Intent的Activity类名

```java
    switch (position) {  
            case 0:  
                Intent intent = new Intent();  
                intent.setClass(it.getContext(), ChallengeFirst.class);  
                it.getContext().startActivity(intent);  
                return;  
            case 1:  
                Intent intent2 = new Intent();  
                intent2.setClass(it.getContext(), ChallengeSecond.class);  
                it.getContext().startActivity(intent2);  
                return;  
            case 2:  
                Intent intent3 = new Intent();  //new一个Intent，
                intent3.setClass(it.getContext(), AdActivity.class);  //传入要切换的Acitivity的类名
                it.getContext().startActivity(intent3);  //启动对应的Activity
                return;  
            case 3:  
                Intent intent4 = new Intent();  
                intent4.setClass(it.getContext(), ChallengeFourth.class);  
                it.getContext().startActivity(intent4);  
                return; 
            default:  
                return;  
        }
```



### 3.Activity生命周期

| 函数名称    | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| onCreate()  | 一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。 |
| onStart()   | 当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。 |
| onResume()  | 这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。 |
| onPause()   | 这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。 |
| onStop()    | 这个方法是在Activity完全不可见的时候调用的。                 |
| onDestroy() | 这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。 |
| onRestart() | 当Activity从停止stop状态恢进入start状态时调用状态。          |

### 5.布局优化 隐藏空间

```
android:visibility="gone"
```

# 五、1000-7=？&动态调试&Log插桩

1.  修改debug权限

   方法一:在AndroidManifest.xml里添加可调试权限

   ```
   android:debuggable="true"
   ```

   方法二：XappDebug模块hook对应的app

   debu模式启动

   ```
   adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity
   ```

   JEB快捷键

   ```
   快捷键：
   ^F6进入方法
   F6跳过方法
   F7从方法中跳出来
   R运行到光标处
   ```

   logo插桩

   ```
   
   invoke-static {对应寄存器}, Lcom/mtools/LogUtils;->v(Ljava/lang/Object;)V
   
   ```

   # 校验的N次方-签名校验对抗、PM代{过}{滤}理、IO重定向

​	

​	2.什么是APK签名

通过对 Apk 进行签名，开发者可以证明对 Apk 的所有权和控制权，可用于安装和更新其应用。而在 Android 设备上的安装 Apk ，如果是一个没有被签名的 Apk，则会被拒绝安装。在安装 Apk 的时候，软件包管理器也会验证 Apk 是否已经被正确签名，并且通过签名证书和数据摘要验证是否合法没有被篡改。只有确认安全无篡改的情况下，才允许安装在设备上。

简单来说，APK 的签名主要作用有两个：

1. 证明 APK 的所有者。
2. 允许 Android 市场和设备校验 APK 的正确性。

Android 目前支持以下四种应用签名方案：
v1 方案：基于 JAR 签名。
v2 方案：APK 签名方案 v2（在 Android 7.0 中引入）
v3 方案：APK 签名方案 v3（在 Android 9 中引入）
v4 方案：APK 签名方案 v4（在 Android 11 中引入）

V1 签名的机制主要就在 META-INF 目录下的三个文件，MANIFEST.MF，ANDROID.SF，ANDROID.RSA，他们都是 V1 签名的产物。
（1）MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。

（2）ANDROID.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。

（3）ANDROID.RSA文件中保存了公钥、所采用的加密算法等信息。
在某些情况下，直接对apk进行v1签名可以绕过apk的签名校验

v2方案会将 APK 文件视为 blob，并对整个文件进行签名检查。对 APK 进行的任何修改（包括对 ZIP 元数据进行的修改）都会使 APK 签名作废。这种形式的 APK 验证不仅速度要快得多，而且能够发现更多种未经授权的修改。

### 3.什么是签名校验

如何判断是否有签名校验？
不做任何修改，直接签名安装，应用闪退则说明大概率有签名校验

一般来说，普通的签名校验会导致软件的闪退，黑屏，卡启动页等
当然，以上都算是比较好的，有一些比较狠的作者，则会直接rm -rf /，把基带都格掉的一键变砖。

```lua
kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因.

system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。

finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理
```

在我个人见过最恶心的签名校验中，当属三角校验(低调大佬教的)最烦人。
所谓三角校验，就是so检测dex，动态加载的dex(在软件运行时会解压释放一段dex文件，检测完后就删除)检测so，dex检测动态加载的dex

HOOK PMS代码:

```java
package com.zj.hookpms;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import android.content.Context;
import android.content.pm.PackageManager;
import android.util.Log;

public class ServiceManagerWraper {

    public final static String ZJ = "ZJ595";

    public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) {
        try {
            // 获取全局的ActivityThread对象
            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");
            Method currentActivityThreadMethod =
                    activityThreadClass.getDeclaredMethod("currentActivityThread");
            Object currentActivityThread = currentActivityThreadMethod.invoke(null);
            // 获取ActivityThread里面原始的sPackageManager
            Field sPackageManagerField = activityThreadClass.getDeclaredField("sPackageManager");
            sPackageManagerField.setAccessible(true);
            Object sPackageManager = sPackageManagerField.get(currentActivityThread);
            // 准备好代{过}{滤}理对象, 用来替换原始的对象
            Class<?> iPackageManagerInterface = Class.forName("android.content.pm.IPackageManager");
            Object proxy = Proxy.newProxyInstance(
                    iPackageManagerInterface.getClassLoader(),
                    new Class<?>[]{iPackageManagerInterface},
                    new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0));
            // 1. 替换掉ActivityThread里面的 sPackageManager 字段
            sPackageManagerField.set(currentActivityThread, proxy);
            // 2. 替换 ApplicationPackageManager里面的 mPM对象
            PackageManager pm = context.getPackageManager();
            Field mPmField = pm.getClass().getDeclaredField("mPM");
            mPmField.setAccessible(true);
            mPmField.set(pm, proxy);
        } catch (Exception e) {
            Log.d(ZJ, "hook pms error:" + Log.getStackTraceString(e));
        }
    }

    public static void hookPMS(Context context) {
        String Sign = "原包的签名信息";
        hookPMS(context, Sign, "com.zj.hookpms", 0);
    }
}

```

### IO重定向

```java
using namespace std;  
string packname;  
string origpath;  
string fakepath;  

int (*orig_open)(const char *pathname, int flags, ...);  
int (*orig_openat)(int,const char *pathname, int flags, ...);  
FILE *(*orig_fopen)(const char *filename, const char *mode);  
static long (*orig_syscall)(long number, ...);  
int (*orig__NR_openat)(int,const char *pathname, int flags, ...);  

void* (*orig_dlopen_CI)(const char *filename, int flag);  
void* (*orig_dlopen_CIV)(const char *filename, int flag, const void *extinfo);  
void* (*orig_dlopen_CIVV)(const char *name, int flags, const void *extinfo, void *caller_addr);  

static inline bool needs_mode(int flags) {  
    return ((flags & O_CREAT) == O_CREAT) || ((flags & O_TMPFILE) == O_TMPFILE);  
}  
bool startsWith(string str, string sub){  
    return str.find(sub)==0;  
}  

bool endsWith(string s,string sub){  
    return s.rfind(sub)==(s.length()-sub.length());  
}  
bool isOrigAPK(string  path){  

    if(path==origpath){  
        return true;  
    }  
    return false;  
}  
//该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径  

//fake_open 函数有三个参数：  
//pathname：一个字符串，表示要打开的文件的路径。  
//flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。  
//mode（可选参数）：一个整数，表示打开文件时应用的权限模式。  
int fake_open(const char *pathname, int flags, ...) {  
    mode_t mode = 0;  
    if (needs_mode(flags)) {  
        va_list args;  
        va_start(args, flags);  
        mode = static_cast<mode_t>(va_arg(args, int));  
        va_end(args);  
    }  
    //LOGI("open,  path: %s, flags: %d, mode: %d",pathname, flags ,mode);  
    string cpp_path= pathname;  
    if(isOrigAPK(cpp_path)){  
        LOGI("libc_open, redirect: %s, --->: %s",pathname, fakepath.data());  
        return orig_open("/data/user/0/com.zj.wuaipojie/files/base.apk", flags, mode);  
    }  
    return  orig_open(pathname, flags, mode);  

}  

//该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径  

//fake_openat 函数有四个参数：  
//fd：一个整数，表示要打开的文件的文件描述符。  
//pathname：一个字符串，表示要打开的文件的路径。  
//flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。  
//mode（可选参数）：一个整数，表示打开文件时应用的权限模式。  
//openat 函数的作用类似于 open 函数，但是它使用文件描述符来指定文件路径，而不是使用文件路径本身。这样，就可以在打开文件时使用相对路径，而不必提供完整的文件路径。  
//例如，如果要打开相对于当前目录的文件，可以使用 openat 函数，而不是 open 函数，因为 open 函数只能使用绝对路径。  
//  
int fake_openat(int fd, const char *pathname, int flags, ...) {  
    mode_t mode = 0;  
    if (needs_mode(flags)) {  
        va_list args;  
        va_start(args, flags);  
        mode = static_cast<mode_t>(va_arg(args, int));  
        va_end(args);  
    }  
    LOGI("openat, fd: %d, path: %s, flags: %d, mode: %d",fd ,pathname, flags ,mode);  
    string cpp_path= pathname;  
    if(isOrigAPK(cpp_path)){  
        LOGI("libc_openat, redirect: %s, --->: %s",pathname, fakepath.data());  
        return  orig_openat(fd,fakepath.data(), flags, mode);  
    }  
    return orig_openat(fd,pathname, flags, mode);  

}  
FILE *fake_fopen(const char *filename, const char *mode) {  

    string cpp_path= filename;  
    if(isOrigAPK(cpp_path)){  
        return  orig_fopen(fakepath.data(), mode);  
    }  
    return orig_fopen(filename, mode);  
}  
//该函数的功能是在执行系统调用时进行拦截，并在满足特定条件时修改系统调用的参数。  
//syscall 函数是一个系统调用，是程序访问内核功能的方法之一。使用 syscall 函数可以调用大量的系统调用，它们用于实现操作系统的各种功能，例如打开文件、创建进程、分配内存等。  
//  
static long fake_syscall(long number, ...) {  
    void *arg[7];  
    va_list list;  

    va_start(list, number);  
    for (int i = 0; i < 7; ++i) {  
        arg[i] = va_arg(list, void *);  
    }  
    va_end(list);  
    if (number == __NR_openat){  
        const char *cpp_path = static_cast<const char *>(arg[1]);  
        LOGI("syscall __NR_openat, fd: %d, path: %s, flags: %d, mode: %d",arg[0] ,arg[1], arg[2], arg[3]);  
        if (isOrigAPK(cpp_path)){  
            LOGI("syscall __NR_openat, redirect: %s, --->: %s",arg[1], fakepath.data());  
            return orig_syscall(number,arg[0], fakepath.data() ,arg[2],arg[3]);  
        }  
    }  
    return orig_syscall(number, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]);  

}  

//函数的功能是获取当前应用的包名、APK 文件路径以及库文件路径，并将这些信息保存在全局变量中  
//函数调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getPackageName 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getPackageName 方法，获取当前应用的包名。最后，函数使用 GetStringUTFChars 函数将包名转换为 C 字符串，并将包名保存在 packname 全局变量中  
//接着，函数使用 fakepath 全局变量保存了 /data/user/0/<packname>/files/base.apk 这样的路径，其中 <packname> 是当前应用的包名。  
//然后，函数再次调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getApplicationInfo 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getApplicationInfo 方法，获取当前应用的 ApplicationInfo 对象。  
//它先调用 GetObjectClass 函数获取 ApplicationInfo 对象的类型，然后调用 GetFieldID 函数获取 sourceDir 字段的 ID。接着，函数使用 GetObjectField 函数获取 sourceDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。最后，函数将 C 字符串保存在 origpath 全局变量中，表示当前应用的 APK 文件路径。  
//最后，函数使用 GetFieldID 和 GetObjectField 函数获取 nativeLibraryDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。函数最后调用 LOGI 函数打印库文件路径，但是并没有将其保存在全局变量中。  

extern "C" JNIEXPORT void JNICALL  
Java_com_zj_wuaipojie_util_SecurityUtil_hook(JNIEnv *env, jclass clazz, jobject context) {  
    jclass conext_class = env->GetObjectClass(context);  
    jmethodID methodId_pack = env->GetMethodID(conext_class, "getPackageName",  
                                               "()Ljava/lang/String;");  
    auto packname_js = reinterpret_cast<jstring>(env->CallObjectMethod(context, methodId_pack));  
    const char *pn = env->GetStringUTFChars(packname_js, 0);  
    packname = string(pn);  

    env->ReleaseStringUTFChars(packname_js, pn);  
    //LOGI("packname: %s", packname.data());  
    fakepath= "/data/user/0/"+ packname +"/files/base.apk";  

    jclass conext_class2 = env->GetObjectClass(context);  
    jmethodID methodId_pack2 = env->GetMethodID(conext_class2,"getApplicationInfo","()Landroid/content/pm/ApplicationInfo;");  
    jobject application_info = env->CallObjectMethod(context,methodId_pack2);  
    jclass pm_clazz = env->GetObjectClass(application_info);  

    jfieldID package_info_id = env->GetFieldID(pm_clazz,"sourceDir","Ljava/lang/String;");  
    auto sourceDir_js = reinterpret_cast<jstring>(env->GetObjectField(application_info,package_info_id));  
    const char *sourceDir = env->GetStringUTFChars(sourceDir_js, 0);  
    origpath = string(sourceDir);  
    LOGI("sourceDir: %s", sourceDir);  

    jfieldID package_info_id2 = env->GetFieldID(pm_clazz,"nativeLibraryDir","Ljava/lang/String;");  
    auto nativeLibraryDir_js = reinterpret_cast<jstring>(env->GetObjectField(application_info,package_info_id2));  
    const char *nativeLibraryDir = env->GetStringUTFChars(nativeLibraryDir_js, 0);  
    LOGI("nativeLibraryDir: %s", nativeLibraryDir);  
    //LOGI("%s", "Start Hook");  

    //启动hook  
    void *handle = dlopen("libc.so",RTLD_NOW);  
    auto pagesize = sysconf(_SC_PAGE_SIZE);  
    auto addr = ((uintptr_t)dlsym(handle,"open") & (-pagesize));  
    auto addr2 = ((uintptr_t)dlsym(handle,"openat") & (-pagesize));  
    auto addr3 = ((uintptr_t)fopen) & (-pagesize);  
    auto addr4 = ((uintptr_t)syscall) & (-pagesize);  

    //解除部分机型open被保护  
    mprotect((void*)addr, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  
    mprotect((void*)addr2, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  
    mprotect((void*)addr3, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  
    mprotect((void*)addr4, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  

    DobbyHook((void *)dlsym(handle,"open"), (void *)fake_open, (void **)&orig_open);  
    DobbyHook((void *)dlsym(handle,"openat"), (void *)fake_openat, (void **)&orig_openat);  
    DobbyHook((void *)fopen, (void *)fake_fopen, (void**)&orig_fopen);  
    DobbyHook((void *)syscall, (void *)fake_syscall, (void **)&orig_syscall);  
}

```

启用方法

```java
        sget-object p10, Lcom/zj/wuaipojie/util/ContextUtils;->INSTANCE:Lcom/zj/wuaipojie/util/ContextUtils;  

    invoke-virtual {p10}, Lcom/zj/wuaipojie/util/ContextUtils;->getContext()Landroid/content/Context;  

    move-result-object p10  

    invoke-static {p10}, Lcom/zj/wuaipojie/util/SecurityUtil;->hook(Landroid/content/Context;)V
```

# xposed编写

在app路径下libs目录粘贴xposedapi

修改xml

```
<!-- 是否是xposed模块，xposed根据这个来判断是否是模块 -->
<meta-data
    android:name="xposedmodule"
    android:value="true" />
<!-- 模块描述，显示在xposed模块列表那里第二行 -->
<meta-data
    android:name="xposeddescription"
    android:value="这是一个Xposed模块" />
<!-- 最低xposed版本号(lib文件名可知) -->
<meta-data
    android:name="xposedminversion"
    android:value="89" />
```

修改build.gradle,将此处修改为compileOnly 默认的是implementation

```
implementation 使用该方式依赖的库将会参与编译和打包
compileOnly 只在编译时有效，不会参与打包
```

新建-->Folder-->Assets Folder，创建xposed_init(不要后缀名):只有一行代码，就是说明入口类

.新建Hook类，实现IXposedHookLoadPackage接口，然后在handleLoadPackage函数内编写Hook逻辑

```
import de.robv.android.xposed.IXposedHookLoadPackage; 
import de.robv.android.xposed.callbacks.XC_LoadPackage;

public class Hook implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable {

    }
}
```

hook普通方法

修复返回值

```
XposedHelpers.findAndHookMethod("com.zj.wuaipojie.Demo", loadPackageParam.classLoader, "a", String.class, new XC_MethodHook() {
    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
        param.setResult(999);
    }
});

```

修改参数

```
XposedHelpers.findAndHookMethod("com.zj.wuaipojie.Demo", loadPackageParam.classLoader, "a", String.class, new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        String a = "pt";
        param.args[0] = a;    }
});

```

hook复杂&自定义函数

```
Class a = loadPackageParam.classLoader.loadClass("类名");
XposedBridge.hookAllMethods(a, "方法名", new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);

        }
});

```

#### Hook替换函数

```
Class a = classLoader.loadClass("类名")
XposedBridge.hookAllMethods(a,"方法名",new XC_MethodReplacement() {  
    home.php?mod=space&uid=1892347  
    protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable {  
        return "";  
    }  
});

```

#### Hook加固通杀

```
XposedHelpers.findAndHookMethod(Application.class, "attach", Context.class, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        Context context = (Context) param.args[0];  
        ClassLoader classLoader = context.getClassLoader();
        //hook逻辑在这里面写  
    }  
});


```

通用hook

```java
XposedHelpers.findAndHookMethod(
    smaliLearnClass,         // 目标类 Class
    "isVip",                 // 目标方法名
    new XC_MethodHook() {    // 回调方法
        @Override
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            param.setResult(99); // 修改返回值
            Log.d("hookvip", "isVip hooked to return 99 (至尊会员)");
        }
    }
);

```

### Hook 带参数的目标方法

```java
XposedHelpers.findAndHookMethod(
    targetClass,            // 目标类 Class
    "someMethod",           // 目标方法名
    int.class,              // 参数 1 类型
    String.class,           // 参数 2 类型
    new XC_MethodHook() {   // 回调方法
        @Override
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            // 修改参数
            param.args[0] = 123;   // 修改第一个参数
            param.args[1] = "newString"; // 修改第二个参数
            Log.d("hookvip", "Modified parameters before method execution");
        }

        @Override
        protected void afterHookedMethod(MethodHookParam param) throws Throwable {
            // 修改返回值
            param.setResult("Modified Result");
            Log.d("hookvip", "Modified method result after execution");
        }
    }
);

```

1. **Hook 返回值的有参方法**（如 `getVip_coin`，无参数）：

   ```
   java复制代码XposedHelpers.findAndHookMethod(smaliLearnClass, "getVip_coin", new XC_MethodHook() {
       @Override
       protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
           param.setResult(9999);
           Log.d("hookvip", "getVip_coin hooked to return 9999");
       }
   });
   ```

2. **Hook 返回时间戳的方法**（如 `vipEndTime`）：

   ```
   java复制代码XposedHelpers.findAndHookMethod(smaliLearnClass, "vipEndTime", new XC_MethodHook() {
       @Override
       protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
           Calendar calendar = Calendar.getInstance();
           calendar.set(2066, Calendar.DECEMBER, 31, 23, 59, 59);
           param.setResult(calendar.getTimeInMillis());
           Log.d("hookvip", "vipEndTime hooked to return 2066-12-31");
       }
   });
   ```

### 1. `XposedHelpers.findAndHookMethod`

用于 Hook 某个类中的特定方法，可以修改参数和返回值。

```
java复制代码// Hook 某个方法，并修改返回值
XposedHelpers.findAndHookMethod(
    Class<?> clazz,               // 要 Hook 的目标类
    String methodName,             // 要 Hook 的方法名称
    Object... parameterTypesAndCallback // 方法参数类型和回调
);
```

**示例**： Hook `isVip()` 方法，将返回值改为 `99`（至尊会员）。

```
java复制代码XposedHelpers.findAndHookMethod(
    smaliLearnClass,               // 目标类 Class
    "isVip",                       // 方法名
    new XC_MethodHook() {          // 回调函数
        @Override
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            param.setResult(99); // 修改返回值
        }
    }
);
```

**使用要点**：

- `Class<?> clazz`：目标类，可以通过 `classLoader.loadClass("类路径")` 获取。
- `String methodName`：方法名称。
- `Object... parameterTypesAndCallback`：方法参数类型和 `XC_MethodHook` 回调。

------

### 2. `XposedHelpers.findAndHookConstructor`

用于 Hook 某个类的构造方法，可以修改初始化参数。

```
java复制代码// Hook 某个类的构造方法
XposedHelpers.findAndHookConstructor(
    Class<?> clazz,               // 要 Hook 的目标类
    Object... parameterTypesAndCallback // 构造函数参数类型和回调
);
```

**示例**： Hook `SomeClass` 的构造方法，修改初始化参数。

```
java复制代码XposedHelpers.findAndHookConstructor(
    someClass,                    // 目标类 Class
    String.class, int.class,      // 构造方法参数类型
    new XC_MethodHook() {
        @Override
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            param.args[0] = "Modified String";  // 修改第一个参数
            param.args[1] = 999;                // 修改第二个参数
        }
    }
);
```

**使用要点**：

- `Class<?> clazz`：要 Hook 的目标类。
- `Object... parameterTypesAndCallback`：构造函数的参数类型和 `XC_MethodHook` 回调。

------

### 3. `XposedHelpers.findAndHookField`

用于 Hook 某个类的字段，可以读取或修改字段值。

```
java复制代码// Hook 某个字段
XposedHelpers.findAndHookField(
    Class<?> clazz,               // 要 Hook 的目标类
    String fieldName,             // 字段名称
    XC_MethodHook callback        // 回调函数
);
```

**示例**： Hook `SomeClass` 中的字段 `vipStatus`，修改其值。

```
java复制代码XposedHelpers.findAndHookField(
    someClass,                     // 目标类 Class
    "vipStatus",                   // 字段名
    new XC_MethodHook() {
        @Override
        protected void afterHookedMethod(MethodHookParam param) throws Throwable {
            // 修改字段值
            Field vipStatusField = someClass.getDeclaredField("vipStatus");
            vipStatusField.setAccessible(true);
            vipStatusField.set(param.thisObject, 99); // 设置为至尊会员状态
        }
    }
);
```

**使用要点**：

- `Class<?> clazz`：目标类。
- `String fieldName`：字段名称。
- `XC_MethodHook callback`：字段 Hook 后的回调。

------

### 4. `XposedHelpers.callMethod`

用于在 Hook 中调用目标类的其他方法。

```
java复制代码// 调用某个方法
XposedHelpers.callMethod(
    Object instance,               // 类实例
    String methodName,             // 方法名称
    Object... args                 // 方法参数
);
```

**示例**： 在 Hook 中调用 `getVipStatus` 方法，获取当前会员状态。

```
java复制代码Object vipStatus = XposedHelpers.callMethod(
    param.thisObject,              // 当前实例
    "getVipStatus"                 // 方法名
);
Log.d("hookvip", "Current VIP Status: " + vipStatus);
```

**使用要点**：

- `Object instance`：类的实例（一般是 `param.thisObject`）。
- `String methodName`：要调用的方法名称。
- `Object... args`：方法参数。

------

### 5. `XposedHelpers.callStaticMethod`

用于调用静态方法，不需要实例。

```java
// 调用静态方法
XposedHelpers.callStaticMethod(
    Class<?> clazz,                // 类
    String methodName,             // 静态方法名称
    Object... args                 // 参数
);
```

**示例**： 调用 `SomeClass` 的静态方法 `getVipLevel`，获取会员等级。

```java
Object vipLevel = XposedHelpers.callStaticMethod(
    someClass,                     // 目标类 Class
    "getVipLevel"                  // 静态方法名
);
Log.d("hookvip", "VIP Level: " + vipLevel);
```

**使用要点**：

- `Class<?> clazz`：要调用静态方法的类。
- `String methodName`：静态方法名称。
- `Object... args`：方法参数。

------

### 6. `XposedHelpers.setObjectField`

用于设置某个对象的字段值，常用于修改对象的私有字段。

```java
java复制代码// 设置对象的字段值
XposedHelpers.setObjectField(
    Object obj,                    // 对象实例
    String fieldName,              // 字段名称
    Object value                   // 新的字段值
);
```

**示例**： 设置 `vipStatus` 字段为 `99`，表示至尊会员。

```java
java复制代码XposedHelpers.setObjectField(
    param.thisObject,              // 当前实例
    "vipStatus",                   // 字段名称
    99                             // 新值
);
```

**使用要点**：

- `Object obj`：目标对象实例。
- `String fieldName`：字段名称。
- `Object value`：新的字段值。

------

### 7. `XposedHelpers.setStaticObjectField`

用于设置静态字段的值。

```
java复制代码// 设置静态字段的值
XposedHelpers.setStaticObjectField(
    Class<?> clazz,                // 目标类
    String fieldName,              // 字段名称
    Object value                   // 新的字段值
);
```java

**示例**： 将 `SomeClass` 的静态字段 `vipType` 设置为 `99`。

```
```
XposedHelpers.setStaticObjectField(
    someClass,                     // 目标类 Class
    "vipType",                     // 静态字段名
    99                             // 新值
);
```



```java

**使用要点**：

- `Class<?> clazz`：目标类。
- `String fieldName`：字段名称。
- `Object value`：新的字段值。

------

### 8. `XposedHelpers.findAndHookAllMethods`

用于 Hook 某个类的所有重载方法，通常在一个方法有多个重载版本时使用。

```java
java复制代码// Hook 所有重载方法
XposedHelpers.findAndHookAllMethods(
    Class<?> clazz,                // 目标类
    String methodName,             // 方法名称
    XC_MethodHook callback         // 回调函数
);
```

**示例**： Hook `SomeClass` 中所有名为 `setVipStatus` 的方法，修改返回值。

```java
java复制代码XposedHelpers.findAndHookAllMethods(
    someClass,                     // 目标类 Class
    "setVipStatus",                // 方法名
    new XC_MethodHook() {
        @Override
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            param.setResult(99);
        }
    }
);
```

** 静态变量**

```java
final Class clazz = XposedHelpers.findClass("类名", classLoader);  
XposedHelpers.setStaticIntField(clazz, "变量名", 999);

```

#### Hook multiDex方法

```java
XposedHelpers.findAndHookMethod(Application.class, "attach", Context.class, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        // 获取应用的 ClassLoader，这样可以在应用启动时访问它的类
        ClassLoader cl = ((Context) param.args[0]).getClassLoader();  
        Class<?> hookclass = null;  

        try {  
            // 动态加载目标类（这里替换为实际的类名），以便后续 Hook 目标方法
            // 使用 ClassLoader 是为了确保类可以被正确加载
            hookclass = cl.loadClass("com.example.app.TargetClass");  
        } catch (Exception e) {  
            // 如果类加载失败，会进入此处，记录未找到类的日志，方便调试
            Log.e("zj2595", "未找到类", e);  
            return;  // 如果找不到目标类，直接返回，不再执行后续代码     
        }  

        // 使用 findAndHookMethod 对指定方法进行 Hook
        // 这里需要提供目标类（hookclass）、方法名和回调（XC_MethodHook）
        XposedHelpers.findAndHookMethod(hookclass, "targetMethod", new XC_MethodHook() {  
            @Override  
            protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
                // 目标方法执行后触发此回调
                Log.d("zj2595", "targetMethod 被 Hook 成功");

                // 修改目标方法的返回值，将其设置为自定义的返回值
                // param.setResult() 可用于在方法执行后更改返回值
                param.setResult("新的返回值");
            }        
        });  
    }  
});

```

静态方法:

```
Class clazz = XposedHelpers.findClass("类名",lpparam.classLoader);
XposedHelpers.callStaticMethod(clazz,"方法名",参数(非必须));
```

实例方法:

```
Class clazz = XposedHelpers.findClass("类名",lpparam.classLoader);
XposedHelpers.callMethod(clazz.newInstance(),"方法名",参数(非必须));

```

#### Hook内部类

内部类:类里还有一个类class

```java
XposedHelpers.findAndHookMethod(
    "com.zj.wuaipojie.Demo$InnerClass", // 要 Hook 的目标类的全限定名（这里是内部类 Demo$InnerClass）
    lpparam.classLoader,                // 类加载器，用于加载目标类
    "innerFunc",                        // 要 Hook 的方法名称
    String.class,                       // 方法的参数类型（这里是 String 类型）
    new XC_MethodHook() {               // 回调，用于在方法执行前后插入代码
        @Override  
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
            // 方法执行前触发此回调
            // 可以修改传入的参数或添加日志

            // super.beforeHookedMethod(param); 不需要调用，因为父类方法为空

            // 获取方法传入的参数（这里是 String 类型），并输出到日志中
            String originalArgument = (String) param.args[0];
            Log.d("zj2595", "innerFunc 原始参数: " + originalArgument);

            // 修改方法的参数（将其修改为 "Modified Argument"）
            param.args[0] = "Modified Argument";
            Log.d("zj2595", "innerFunc 参数已被修改");
        }  
    }
);


```

# 无敌反射大法

```java
// 首先找到目标类 Demo
Class clazz = XposedHelpers.findClass("com.zj.wuaipojie.Demo", lpparam.classLoader);

// Hook Demo$InnerClass 的 innerFunc 方法
XposedHelpers.findAndHookMethod(
    "com.zj.wuaipojie.Demo$InnerClass", // 要 Hook 的内部类（Demo$InnerClass）
    lpparam.classLoader,                // 类加载器，用于加载目标类
    "innerFunc",                        // 要 Hook 的方法名称
    String.class,                       // 方法的参数类型（这里是 String 类型）
    new XC_MethodHook() {               // 回调，用于在方法执行前后插入代码
        @Override  
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
            // 不需要调用 super.beforeHookedMethod(param) 因为它在 Xposed 中为空实现

            // 第一步：找到 Demo 类
            Class<?> democlass = Class.forName("com.zj.wuaipojie.Demo", false, lpparam.classLoader);

            // 第二步：找到 Demo 类中的私有方法 refl
            // 使用 getDeclaredMethod，因为 refl 是私有方法（假设）
            Method demomethod = democlass.getDeclaredMethod("refl");

            // 第三步：设置访问权限，允许访问私有方法
            demomethod.setAccessible(true);

            // 第四步：调用私有方法 refl
            // 使用 clazz.newInstance() 创建 Demo 的实例对象
            // 然后调用 refl 方法。注意，newInstance() 仅适用于无参构造函数
            //或者使用set修改值(变量)
            demomethod.invoke(clazz.newInstance());

            // 输出日志确认方法调用成功
            Log.d("zj2595", "Demo 类的私有方法 refl 已被成功调用");
        }  
    }
);

```

1. ### 代码流程和说明

   1. **找到目标类 `Demo`**：

      ```java
      
      Class clazz = XposedHelpers.findClass("com.zj.wuaipojie.Demo", lpparam.classLoader);
      ```

      - 使用 `XposedHelpers.findClass` 获取目标类 `Demo` 的 `Class` 对象，并赋值给 `clazz`。
      - `lpparam.classLoader` 是 `LoadPackageParam` 的 `classLoader`，用来加载目标应用的类。

   2. **Hook `Demo$InnerClass` 的 `innerFunc` 方法**：

      ```java
      XposedHelpers.findAndHookMethod(
          "com.zj.wuaipojie.Demo$InnerClass", lpparam.classLoader, "innerFunc", String.class, new XC_MethodHook() {...}
      );
      ```

      - 使用 `findAndHookMethod` 对 `Demo$InnerClass` 的 `innerFunc` 方法进行 Hook，在方法执行前调用 `beforeHookedMethod` 回调。
      - `innerFunc` 的参数类型为 `String.class`，确保传入的类型与方法签名匹配。

   3. **获取 `Demo` 类的私有方法 `refl`**：

      ```java
      
      Method demomethod = democlass.getDeclaredMethod("refl");
      ```

      - 通过 `democlass.getDeclaredMethod("refl")` 获取 `Demo` 类中的私有方法 `refl`。
      - `getDeclaredMethod` 能获取类中的私有方法，而 `getMethod` 只能获取公共方法。

   4. **设置方法的访问权限**：

      ```java
      
      demomethod.setAccessible(true);
      ```

      - `setAccessible(true)` 允许访问私有方法 `refl`，否则无法调用它。
      - 这是 Java 反射的常用技巧，用于访问和调用私有方法或字段。

   5. **调用私有方法 `refl`**：

      ```java
      
      demomethod.invoke(clazz.newInstance());
      ```

      - 使用 `demomethod.invoke(clazz.newInstance())` 调用 `refl` 方法。
      - `clazz.newInstance()` 创建一个 `Demo` 类的实例对象，并将其作为 `invoke` 的目标对象。
      - **注意**：`newInstance()` 只能调用无参构造函数。如果 `Demo` 类没有无参构造函数，或者构造函数有参数，则需要使用 `Constructor` 来创建实例。

   6. **日志输出**：

      ```java
      
      Log.d("zj2595", "Demo 类的私有方法 refl 已被成功调用");
      ```

      - 输出日志，确认私有方法 `refl` 已成功调用。

# 遍历所有类下的所有方法

```java
// 钩住 ClassLoader 类的 loadClass 方法
XposedHelpers.findAndHookMethod(ClassLoader.class, "loadClass", String.class, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        // 调用原始方法
        super.afterHookedMethod(param);  
        
        // 获取加载的类
        Class clazz = (Class) param.getResult();  
        String clazzName = clazz.getName();  
        
        // 检查加载的类是否属于指定的包
        // （在本例中是 "com.zj.wuaipojie"）
        if(clazzName.contains("com.zj.wuaipojie")){  
            // 获取加载类的所有声明的方法
            Method[] mds = clazz.getDeclaredMethods();  
            for(int i = 0; i < mds.length; i++){  
                final Method md = mds[i];  
                
                // 获取方法的修饰符
                int mod = mds[i].getModifiers();  
                
                // 排除抽象、native 和接口方法
                if(!Modifier.isAbstract(mod)  
                    && !Modifier.isNative(mod)  
                    && !Modifier.isInterface(mod)){  
                    
                    // 钩住方法以记录其调用
                    XposedBridge.hookMethod(mds[i], new XC_MethodHook() {  
                        @Override  
                        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
                            // 在调用钩子前调用原始方法
                            super.beforeHookedMethod(param);  
                            
                            // 记录被调用的方法
                            Log.d("zj2595", md.toString());  
                        }  
                    });  
                }  
            }  
        }  
    }  
});

```

## 字符串赋值定位:

```java
// 钩住 android.widget.TextView 类的 setText 方法
XposedHelpers.findAndHookMethod("android.widget.TextView", lpparam.classLoader, "setText", CharSequence.class, new XC_MethodHook() {  
    @Override  
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
        // 调用原始方法之前
        super.beforeHookedMethod(param);  
        
        // 记录 setText 方法传入的参数
        Log.d("zj2595", param.args[0].toString());  
        
        // 检查传入的参数是否为 "已过期"
        if(param.args[0].equals("已过期")){  
            // 打印调用堆栈
            printStackTrace();  
        }
    }  
});

// 自定义方法，用于打印调用堆栈
private static void printStackTrace() {  
    // 创建一个 Throwable 对象以获取当前堆栈信息
    Throwable ex = new Throwable();  
    // 获取堆栈元素
    StackTraceElement[] stackElements = ex.getStackTrace();  
    
    // 遍历并记录堆栈信息
    for (int i = 0; i < stackElements.length; i++) {  
        StackTraceElement element = stackElements[i];  
        // 记录每个堆栈元素的信息
        Log.d("zj2595", "at " + element.getClassName() + "." + element.getMethodName() + "(" + element.getFileName() + ":" + element.getLineNumber() + ")");  
    }  
}

```

点击事件监听:

```java
// 查找 android.view.View 类
Class clazz = XposedHelpers.findClass("android.view.View", lpparam.classLoader);

// 钩住 View 类的 performClick 方法
XposedBridge.hookAllMethods(clazz, "performClick", new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        // 调用原始方法
        super.afterHookedMethod(param);  

        // 获取 View 对象的 mListenerInfo 字段
        Object listenerInfoObject = XposedHelpers.getObjectField(param.thisObject, "mListenerInfo");  

        // 从 mListenerInfo 中获取 mOnClickListener 字段
        Object mOnClickListenerObject = XposedHelpers.getObjectField(listenerInfoObject, "mOnClickListener");  

        // 获取并记录监听器的类名
        String callbackType = mOnClickListenerObject.getClass().getName();  
        Log.d("zj2595", callbackType);  
    }  
});

```



改写布局:

```java
// 钩住 com.zj.wuaipojie.ui.ChallengeSixth 类的 onCreate 方法
XposedHelpers.findAndHookMethod("com.zj.wuaipojie.ui.ChallengeSixth", lpparam.classLoader,  
        "onCreate", Bundle.class, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        // 调用原始 onCreate 方法
        super.afterHookedMethod(param);  
        
        // 通过 findViewById 方法获取特定的视图
        View img = (View)XposedHelpers.callMethod(param.thisObject, "findViewById", 0x7f0800de);  
        
        // 将获取的视图设置为不可见
        img.setVisibility(View.GONE);  
    }  
});

```
![[Pasted image 20241031172951.png]]
函数的基本介绍：

| 函数名                                              | 描述                                                                                                                                                                                                          |
| ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `android_dlopen_ext()` 、`dlopen()`、`do_dlopen()` | 这三个函数主要用于加载库文件。`android_dlopen_ext` 是系统的一个函数，用于在运行时动态加载共享库。与标准的 `dlopen()` 函数相比，`android_dlopen_ext` 提供了更多的参数选项和扩展功能，例如支持命名空间、符号版本等特性。                                                                      |
| `find_library()`                                 | `find_library()` 函数用于查找库，基本的用途是给定一个库的名字，然后查找并返回这个库的路径。                                                                                                                                                      |
| `call_constructors()`                            | `call_constructors()` 是用于调用动态加载库中的构造函数的函数。                                                                                                                                                                  |
| `init`                                           | 库的构造函数，用于初始化库中的静态变量或执行其他需要在库被加载时完成的任务。如果没有定义`init`函数，系统将不会执行任何动作。需要注意的是，`init`函数不应该有任何参数，并且也没有返回值。                                                                                                          |
| `init_array`                                     | `init_array`是ELF（Executable and Linkable Format，可执行和可链接格式）二进制格式中的一个特殊段（section），这个段包含了一些函数的指针，这些函数将在`main()`函数执行前被调用，用于初始化静态局部变量和全局变量。                                                                      |
| `jni_onload`                                     | 这是Android JNI(Java Native Interface)中的一个函数。当一个native库被系统加载时，该函数会被自动调用。`JNI_OnLoad`可以做一些初始化工作，例如注册你的native方法或者初始化一些数据结构。如果你的native库没有定义这个函数，那么JNI会使用默认的行为。`JNI_OnLoad`的返回值应该是需要的JNI版本，一般返回`JNI_VERSION_1_6`。 |

下断点时机：  
应用级别的：java_com_XXX；  
外壳级别的：JNI_Onload，.init，.init_array(反调试);  
系统级别的：fopen，fget，dvmdexfileopen(脱壳)；
  ## ida 动态调试
#### 1.前置操作：

1.在IDA目录下的dbgsrv，选择跟手机架构一致的server  
2.adb push as /data/local/tmp/  
3.进入手机端命令：adb shell  
4.切换获取手机的root权限：su  
5.跳到对应路径：cd /data/local/tmp/  
6.提权：chmod 777 as  
7.XappDebug hook

#### 2.调试步骤

分为两种模式，一种是以debug模式启动，第二种则以普通模式启动，二者的区别在于使用场景，有时候要动态调试的参数在app一启动的时候就产生了，时机较早，所以需要以debug模式去挂起app

 _复制代码_ _隐藏代码_
 `adb shell am start -D -n com.zj.wuaipojie/.ui.ChallengeEight （去掉-D 则表示不以debug模式启动app）
 ` adb forward tcp:23946 tcp:23946 (端口转发) 
  `adb forward tcp:8700 jdwp:PID (pid监听) jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 (jdb挂起)`

PS：若不是以debug启动则不需要输入后两条命令  
其他的步骤具体看视频``

PS：若不是以debug启动则不需要输入后两条命令  
其他的步骤具体看视频